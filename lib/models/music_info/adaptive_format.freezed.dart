// coverage:ignore-file
// GENERATED CODE - DO NOT MODIFY BY HAND
// ignore_for_file: type=lint
// ignore_for_file: unused_element, deprecated_member_use, deprecated_member_use_from_same_package, use_function_type_syntax_for_parameters, unnecessary_const, avoid_init_to_null, invalid_override_different_default_values_named, prefer_expression_function_bodies, annotate_overrides, invalid_annotation_target, unnecessary_question_mark

part of 'adaptive_format.dart';

// **************************************************************************
// FreezedGenerator
// **************************************************************************

T _$identity<T>(T value) => value;

final _privateConstructorUsedError = UnsupportedError(
    'It seems like you constructed your class using `MyClass._()`. This constructor is only meant to be used by freezed and you are not supposed to need it nor use it.\nPlease check the documentation here for more information: https://github.com/rrousselGit/freezed#adding-getters-and-methods-to-our-models');

AdaptiveFormat _$AdaptiveFormatFromJson(Map<String, dynamic> json) {
  return _AdaptiveFormat.fromJson(json);
}

/// @nodoc
mixin _$AdaptiveFormat {
  int? get itag => throw _privateConstructorUsedError;
  String? get url => throw _privateConstructorUsedError;
  String? get mimeType => throw _privateConstructorUsedError;
  int? get bitrate => throw _privateConstructorUsedError;
  int? get width => throw _privateConstructorUsedError;
  int? get height => throw _privateConstructorUsedError;
  InitRange? get initRange => throw _privateConstructorUsedError;
  IndexRange? get indexRange => throw _privateConstructorUsedError;
  String? get lastModified => throw _privateConstructorUsedError;
  String? get contentLength => throw _privateConstructorUsedError;
  String? get quality => throw _privateConstructorUsedError;
  int? get fps => throw _privateConstructorUsedError;
  String? get qualityLabel => throw _privateConstructorUsedError;
  String? get projectionType => throw _privateConstructorUsedError;
  int? get averageBitrate => throw _privateConstructorUsedError;
  String? get approxDurationMs => throw _privateConstructorUsedError;
  ColorInfo? get colorInfo => throw _privateConstructorUsedError;
  bool? get highReplication => throw _privateConstructorUsedError;
  String? get audioQuality => throw _privateConstructorUsedError;
  String? get audioSampleRate => throw _privateConstructorUsedError;
  int? get audioChannels => throw _privateConstructorUsedError;
  double? get loudnessDb => throw _privateConstructorUsedError;

  /// Serializes this AdaptiveFormat to a JSON map.
  Map<String, dynamic> toJson() => throw _privateConstructorUsedError;

  /// Create a copy of AdaptiveFormat
  /// with the given fields replaced by the non-null parameter values.
  @JsonKey(includeFromJson: false, includeToJson: false)
  $AdaptiveFormatCopyWith<AdaptiveFormat> get copyWith =>
      throw _privateConstructorUsedError;
}

/// @nodoc
abstract class $AdaptiveFormatCopyWith<$Res> {
  factory $AdaptiveFormatCopyWith(
          AdaptiveFormat value, $Res Function(AdaptiveFormat) then) =
      _$AdaptiveFormatCopyWithImpl<$Res, AdaptiveFormat>;
  @useResult
  $Res call(
      {int? itag,
      String? url,
      String? mimeType,
      int? bitrate,
      int? width,
      int? height,
      InitRange? initRange,
      IndexRange? indexRange,
      String? lastModified,
      String? contentLength,
      String? quality,
      int? fps,
      String? qualityLabel,
      String? projectionType,
      int? averageBitrate,
      String? approxDurationMs,
      ColorInfo? colorInfo,
      bool? highReplication,
      String? audioQuality,
      String? audioSampleRate,
      int? audioChannels,
      double? loudnessDb});

  $InitRangeCopyWith<$Res>? get initRange;
  $IndexRangeCopyWith<$Res>? get indexRange;
  $ColorInfoCopyWith<$Res>? get colorInfo;
}

/// @nodoc
class _$AdaptiveFormatCopyWithImpl<$Res, $Val extends AdaptiveFormat>
    implements $AdaptiveFormatCopyWith<$Res> {
  _$AdaptiveFormatCopyWithImpl(this._value, this._then);

  // ignore: unused_field
  final $Val _value;
  // ignore: unused_field
  final $Res Function($Val) _then;

  /// Create a copy of AdaptiveFormat
  /// with the given fields replaced by the non-null parameter values.
  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? itag = freezed,
    Object? url = freezed,
    Object? mimeType = freezed,
    Object? bitrate = freezed,
    Object? width = freezed,
    Object? height = freezed,
    Object? initRange = freezed,
    Object? indexRange = freezed,
    Object? lastModified = freezed,
    Object? contentLength = freezed,
    Object? quality = freezed,
    Object? fps = freezed,
    Object? qualityLabel = freezed,
    Object? projectionType = freezed,
    Object? averageBitrate = freezed,
    Object? approxDurationMs = freezed,
    Object? colorInfo = freezed,
    Object? highReplication = freezed,
    Object? audioQuality = freezed,
    Object? audioSampleRate = freezed,
    Object? audioChannels = freezed,
    Object? loudnessDb = freezed,
  }) {
    return _then(_value.copyWith(
      itag: freezed == itag
          ? _value.itag
          : itag // ignore: cast_nullable_to_non_nullable
              as int?,
      url: freezed == url
          ? _value.url
          : url // ignore: cast_nullable_to_non_nullable
              as String?,
      mimeType: freezed == mimeType
          ? _value.mimeType
          : mimeType // ignore: cast_nullable_to_non_nullable
              as String?,
      bitrate: freezed == bitrate
          ? _value.bitrate
          : bitrate // ignore: cast_nullable_to_non_nullable
              as int?,
      width: freezed == width
          ? _value.width
          : width // ignore: cast_nullable_to_non_nullable
              as int?,
      height: freezed == height
          ? _value.height
          : height // ignore: cast_nullable_to_non_nullable
              as int?,
      initRange: freezed == initRange
          ? _value.initRange
          : initRange // ignore: cast_nullable_to_non_nullable
              as InitRange?,
      indexRange: freezed == indexRange
          ? _value.indexRange
          : indexRange // ignore: cast_nullable_to_non_nullable
              as IndexRange?,
      lastModified: freezed == lastModified
          ? _value.lastModified
          : lastModified // ignore: cast_nullable_to_non_nullable
              as String?,
      contentLength: freezed == contentLength
          ? _value.contentLength
          : contentLength // ignore: cast_nullable_to_non_nullable
              as String?,
      quality: freezed == quality
          ? _value.quality
          : quality // ignore: cast_nullable_to_non_nullable
              as String?,
      fps: freezed == fps
          ? _value.fps
          : fps // ignore: cast_nullable_to_non_nullable
              as int?,
      qualityLabel: freezed == qualityLabel
          ? _value.qualityLabel
          : qualityLabel // ignore: cast_nullable_to_non_nullable
              as String?,
      projectionType: freezed == projectionType
          ? _value.projectionType
          : projectionType // ignore: cast_nullable_to_non_nullable
              as String?,
      averageBitrate: freezed == averageBitrate
          ? _value.averageBitrate
          : averageBitrate // ignore: cast_nullable_to_non_nullable
              as int?,
      approxDurationMs: freezed == approxDurationMs
          ? _value.approxDurationMs
          : approxDurationMs // ignore: cast_nullable_to_non_nullable
              as String?,
      colorInfo: freezed == colorInfo
          ? _value.colorInfo
          : colorInfo // ignore: cast_nullable_to_non_nullable
              as ColorInfo?,
      highReplication: freezed == highReplication
          ? _value.highReplication
          : highReplication // ignore: cast_nullable_to_non_nullable
              as bool?,
      audioQuality: freezed == audioQuality
          ? _value.audioQuality
          : audioQuality // ignore: cast_nullable_to_non_nullable
              as String?,
      audioSampleRate: freezed == audioSampleRate
          ? _value.audioSampleRate
          : audioSampleRate // ignore: cast_nullable_to_non_nullable
              as String?,
      audioChannels: freezed == audioChannels
          ? _value.audioChannels
          : audioChannels // ignore: cast_nullable_to_non_nullable
              as int?,
      loudnessDb: freezed == loudnessDb
          ? _value.loudnessDb
          : loudnessDb // ignore: cast_nullable_to_non_nullable
              as double?,
    ) as $Val);
  }

  /// Create a copy of AdaptiveFormat
  /// with the given fields replaced by the non-null parameter values.
  @override
  @pragma('vm:prefer-inline')
  $InitRangeCopyWith<$Res>? get initRange {
    if (_value.initRange == null) {
      return null;
    }

    return $InitRangeCopyWith<$Res>(_value.initRange!, (value) {
      return _then(_value.copyWith(initRange: value) as $Val);
    });
  }

  /// Create a copy of AdaptiveFormat
  /// with the given fields replaced by the non-null parameter values.
  @override
  @pragma('vm:prefer-inline')
  $IndexRangeCopyWith<$Res>? get indexRange {
    if (_value.indexRange == null) {
      return null;
    }

    return $IndexRangeCopyWith<$Res>(_value.indexRange!, (value) {
      return _then(_value.copyWith(indexRange: value) as $Val);
    });
  }

  /// Create a copy of AdaptiveFormat
  /// with the given fields replaced by the non-null parameter values.
  @override
  @pragma('vm:prefer-inline')
  $ColorInfoCopyWith<$Res>? get colorInfo {
    if (_value.colorInfo == null) {
      return null;
    }

    return $ColorInfoCopyWith<$Res>(_value.colorInfo!, (value) {
      return _then(_value.copyWith(colorInfo: value) as $Val);
    });
  }
}

/// @nodoc
abstract class _$$AdaptiveFormatImplCopyWith<$Res>
    implements $AdaptiveFormatCopyWith<$Res> {
  factory _$$AdaptiveFormatImplCopyWith(_$AdaptiveFormatImpl value,
          $Res Function(_$AdaptiveFormatImpl) then) =
      __$$AdaptiveFormatImplCopyWithImpl<$Res>;
  @override
  @useResult
  $Res call(
      {int? itag,
      String? url,
      String? mimeType,
      int? bitrate,
      int? width,
      int? height,
      InitRange? initRange,
      IndexRange? indexRange,
      String? lastModified,
      String? contentLength,
      String? quality,
      int? fps,
      String? qualityLabel,
      String? projectionType,
      int? averageBitrate,
      String? approxDurationMs,
      ColorInfo? colorInfo,
      bool? highReplication,
      String? audioQuality,
      String? audioSampleRate,
      int? audioChannels,
      double? loudnessDb});

  @override
  $InitRangeCopyWith<$Res>? get initRange;
  @override
  $IndexRangeCopyWith<$Res>? get indexRange;
  @override
  $ColorInfoCopyWith<$Res>? get colorInfo;
}

/// @nodoc
class __$$AdaptiveFormatImplCopyWithImpl<$Res>
    extends _$AdaptiveFormatCopyWithImpl<$Res, _$AdaptiveFormatImpl>
    implements _$$AdaptiveFormatImplCopyWith<$Res> {
  __$$AdaptiveFormatImplCopyWithImpl(
      _$AdaptiveFormatImpl _value, $Res Function(_$AdaptiveFormatImpl) _then)
      : super(_value, _then);

  /// Create a copy of AdaptiveFormat
  /// with the given fields replaced by the non-null parameter values.
  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? itag = freezed,
    Object? url = freezed,
    Object? mimeType = freezed,
    Object? bitrate = freezed,
    Object? width = freezed,
    Object? height = freezed,
    Object? initRange = freezed,
    Object? indexRange = freezed,
    Object? lastModified = freezed,
    Object? contentLength = freezed,
    Object? quality = freezed,
    Object? fps = freezed,
    Object? qualityLabel = freezed,
    Object? projectionType = freezed,
    Object? averageBitrate = freezed,
    Object? approxDurationMs = freezed,
    Object? colorInfo = freezed,
    Object? highReplication = freezed,
    Object? audioQuality = freezed,
    Object? audioSampleRate = freezed,
    Object? audioChannels = freezed,
    Object? loudnessDb = freezed,
  }) {
    return _then(_$AdaptiveFormatImpl(
      itag: freezed == itag
          ? _value.itag
          : itag // ignore: cast_nullable_to_non_nullable
              as int?,
      url: freezed == url
          ? _value.url
          : url // ignore: cast_nullable_to_non_nullable
              as String?,
      mimeType: freezed == mimeType
          ? _value.mimeType
          : mimeType // ignore: cast_nullable_to_non_nullable
              as String?,
      bitrate: freezed == bitrate
          ? _value.bitrate
          : bitrate // ignore: cast_nullable_to_non_nullable
              as int?,
      width: freezed == width
          ? _value.width
          : width // ignore: cast_nullable_to_non_nullable
              as int?,
      height: freezed == height
          ? _value.height
          : height // ignore: cast_nullable_to_non_nullable
              as int?,
      initRange: freezed == initRange
          ? _value.initRange
          : initRange // ignore: cast_nullable_to_non_nullable
              as InitRange?,
      indexRange: freezed == indexRange
          ? _value.indexRange
          : indexRange // ignore: cast_nullable_to_non_nullable
              as IndexRange?,
      lastModified: freezed == lastModified
          ? _value.lastModified
          : lastModified // ignore: cast_nullable_to_non_nullable
              as String?,
      contentLength: freezed == contentLength
          ? _value.contentLength
          : contentLength // ignore: cast_nullable_to_non_nullable
              as String?,
      quality: freezed == quality
          ? _value.quality
          : quality // ignore: cast_nullable_to_non_nullable
              as String?,
      fps: freezed == fps
          ? _value.fps
          : fps // ignore: cast_nullable_to_non_nullable
              as int?,
      qualityLabel: freezed == qualityLabel
          ? _value.qualityLabel
          : qualityLabel // ignore: cast_nullable_to_non_nullable
              as String?,
      projectionType: freezed == projectionType
          ? _value.projectionType
          : projectionType // ignore: cast_nullable_to_non_nullable
              as String?,
      averageBitrate: freezed == averageBitrate
          ? _value.averageBitrate
          : averageBitrate // ignore: cast_nullable_to_non_nullable
              as int?,
      approxDurationMs: freezed == approxDurationMs
          ? _value.approxDurationMs
          : approxDurationMs // ignore: cast_nullable_to_non_nullable
              as String?,
      colorInfo: freezed == colorInfo
          ? _value.colorInfo
          : colorInfo // ignore: cast_nullable_to_non_nullable
              as ColorInfo?,
      highReplication: freezed == highReplication
          ? _value.highReplication
          : highReplication // ignore: cast_nullable_to_non_nullable
              as bool?,
      audioQuality: freezed == audioQuality
          ? _value.audioQuality
          : audioQuality // ignore: cast_nullable_to_non_nullable
              as String?,
      audioSampleRate: freezed == audioSampleRate
          ? _value.audioSampleRate
          : audioSampleRate // ignore: cast_nullable_to_non_nullable
              as String?,
      audioChannels: freezed == audioChannels
          ? _value.audioChannels
          : audioChannels // ignore: cast_nullable_to_non_nullable
              as int?,
      loudnessDb: freezed == loudnessDb
          ? _value.loudnessDb
          : loudnessDb // ignore: cast_nullable_to_non_nullable
              as double?,
    ));
  }
}

/// @nodoc
@JsonSerializable()
class _$AdaptiveFormatImpl implements _AdaptiveFormat {
  _$AdaptiveFormatImpl(
      {this.itag,
      this.url,
      this.mimeType,
      this.bitrate,
      this.width,
      this.height,
      this.initRange,
      this.indexRange,
      this.lastModified,
      this.contentLength,
      this.quality,
      this.fps,
      this.qualityLabel,
      this.projectionType,
      this.averageBitrate,
      this.approxDurationMs,
      this.colorInfo,
      this.highReplication,
      this.audioQuality,
      this.audioSampleRate,
      this.audioChannels,
      this.loudnessDb});

  factory _$AdaptiveFormatImpl.fromJson(Map<String, dynamic> json) =>
      _$$AdaptiveFormatImplFromJson(json);

  @override
  final int? itag;
  @override
  final String? url;
  @override
  final String? mimeType;
  @override
  final int? bitrate;
  @override
  final int? width;
  @override
  final int? height;
  @override
  final InitRange? initRange;
  @override
  final IndexRange? indexRange;
  @override
  final String? lastModified;
  @override
  final String? contentLength;
  @override
  final String? quality;
  @override
  final int? fps;
  @override
  final String? qualityLabel;
  @override
  final String? projectionType;
  @override
  final int? averageBitrate;
  @override
  final String? approxDurationMs;
  @override
  final ColorInfo? colorInfo;
  @override
  final bool? highReplication;
  @override
  final String? audioQuality;
  @override
  final String? audioSampleRate;
  @override
  final int? audioChannels;
  @override
  final double? loudnessDb;

  @override
  String toString() {
    return 'AdaptiveFormat(itag: $itag, url: $url, mimeType: $mimeType, bitrate: $bitrate, width: $width, height: $height, initRange: $initRange, indexRange: $indexRange, lastModified: $lastModified, contentLength: $contentLength, quality: $quality, fps: $fps, qualityLabel: $qualityLabel, projectionType: $projectionType, averageBitrate: $averageBitrate, approxDurationMs: $approxDurationMs, colorInfo: $colorInfo, highReplication: $highReplication, audioQuality: $audioQuality, audioSampleRate: $audioSampleRate, audioChannels: $audioChannels, loudnessDb: $loudnessDb)';
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$AdaptiveFormatImpl &&
            (identical(other.itag, itag) || other.itag == itag) &&
            (identical(other.url, url) || other.url == url) &&
            (identical(other.mimeType, mimeType) ||
                other.mimeType == mimeType) &&
            (identical(other.bitrate, bitrate) || other.bitrate == bitrate) &&
            (identical(other.width, width) || other.width == width) &&
            (identical(other.height, height) || other.height == height) &&
            (identical(other.initRange, initRange) ||
                other.initRange == initRange) &&
            (identical(other.indexRange, indexRange) ||
                other.indexRange == indexRange) &&
            (identical(other.lastModified, lastModified) ||
                other.lastModified == lastModified) &&
            (identical(other.contentLength, contentLength) ||
                other.contentLength == contentLength) &&
            (identical(other.quality, quality) || other.quality == quality) &&
            (identical(other.fps, fps) || other.fps == fps) &&
            (identical(other.qualityLabel, qualityLabel) ||
                other.qualityLabel == qualityLabel) &&
            (identical(other.projectionType, projectionType) ||
                other.projectionType == projectionType) &&
            (identical(other.averageBitrate, averageBitrate) ||
                other.averageBitrate == averageBitrate) &&
            (identical(other.approxDurationMs, approxDurationMs) ||
                other.approxDurationMs == approxDurationMs) &&
            (identical(other.colorInfo, colorInfo) ||
                other.colorInfo == colorInfo) &&
            (identical(other.highReplication, highReplication) ||
                other.highReplication == highReplication) &&
            (identical(other.audioQuality, audioQuality) ||
                other.audioQuality == audioQuality) &&
            (identical(other.audioSampleRate, audioSampleRate) ||
                other.audioSampleRate == audioSampleRate) &&
            (identical(other.audioChannels, audioChannels) ||
                other.audioChannels == audioChannels) &&
            (identical(other.loudnessDb, loudnessDb) ||
                other.loudnessDb == loudnessDb));
  }

  @JsonKey(includeFromJson: false, includeToJson: false)
  @override
  int get hashCode => Object.hashAll([
        runtimeType,
        itag,
        url,
        mimeType,
        bitrate,
        width,
        height,
        initRange,
        indexRange,
        lastModified,
        contentLength,
        quality,
        fps,
        qualityLabel,
        projectionType,
        averageBitrate,
        approxDurationMs,
        colorInfo,
        highReplication,
        audioQuality,
        audioSampleRate,
        audioChannels,
        loudnessDb
      ]);

  /// Create a copy of AdaptiveFormat
  /// with the given fields replaced by the non-null parameter values.
  @JsonKey(includeFromJson: false, includeToJson: false)
  @override
  @pragma('vm:prefer-inline')
  _$$AdaptiveFormatImplCopyWith<_$AdaptiveFormatImpl> get copyWith =>
      __$$AdaptiveFormatImplCopyWithImpl<_$AdaptiveFormatImpl>(
          this, _$identity);

  @override
  Map<String, dynamic> toJson() {
    return _$$AdaptiveFormatImplToJson(
      this,
    );
  }
}

abstract class _AdaptiveFormat implements AdaptiveFormat {
  factory _AdaptiveFormat(
      {final int? itag,
      final String? url,
      final String? mimeType,
      final int? bitrate,
      final int? width,
      final int? height,
      final InitRange? initRange,
      final IndexRange? indexRange,
      final String? lastModified,
      final String? contentLength,
      final String? quality,
      final int? fps,
      final String? qualityLabel,
      final String? projectionType,
      final int? averageBitrate,
      final String? approxDurationMs,
      final ColorInfo? colorInfo,
      final bool? highReplication,
      final String? audioQuality,
      final String? audioSampleRate,
      final int? audioChannels,
      final double? loudnessDb}) = _$AdaptiveFormatImpl;

  factory _AdaptiveFormat.fromJson(Map<String, dynamic> json) =
      _$AdaptiveFormatImpl.fromJson;

  @override
  int? get itag;
  @override
  String? get url;
  @override
  String? get mimeType;
  @override
  int? get bitrate;
  @override
  int? get width;
  @override
  int? get height;
  @override
  InitRange? get initRange;
  @override
  IndexRange? get indexRange;
  @override
  String? get lastModified;
  @override
  String? get contentLength;
  @override
  String? get quality;
  @override
  int? get fps;
  @override
  String? get qualityLabel;
  @override
  String? get projectionType;
  @override
  int? get averageBitrate;
  @override
  String? get approxDurationMs;
  @override
  ColorInfo? get colorInfo;
  @override
  bool? get highReplication;
  @override
  String? get audioQuality;
  @override
  String? get audioSampleRate;
  @override
  int? get audioChannels;
  @override
  double? get loudnessDb;

  /// Create a copy of AdaptiveFormat
  /// with the given fields replaced by the non-null parameter values.
  @override
  @JsonKey(includeFromJson: false, includeToJson: false)
  _$$AdaptiveFormatImplCopyWith<_$AdaptiveFormatImpl> get copyWith =>
      throw _privateConstructorUsedError;
}
